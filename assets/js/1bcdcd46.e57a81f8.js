"use strict";(self.webpackChunkworkshop_pairprogramming_site=self.webpackChunkworkshop_pairprogramming_site||[]).push([[5580],{454:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"glossary/yagni","title":"YAGNI (You Aren\'t Gonna Need It)","description":"A principle in agile software development that encourages avoiding unnecessary features. YAGNI helps teams focus on essential tasks to improve productivity.","source":"@site/docs/glossary/yagni.md","sourceDirName":"glossary","slug":"/glossary/yagni","permalink":"/docs/glossary/yagni","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Test-First Pairing","permalink":"/docs/glossary/test_first_pairing"}}');var a=i(4848),s=i(8453);const o={},r="YAGNI (You Aren't Gonna Need It)",c={},l=[{value:"Theoretical Foundation",id:"theoretical-foundation",level:2},{value:"Common Misapplications",id:"common-misapplications",level:2},{value:"Practical Application",id:"practical-application",level:2}];function p(e){const t={h1:"h1",h2:"h2",header:"header",p:"p",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"yagni-you-arent-gonna-need-it",children:"YAGNI (You Aren't Gonna Need It)"})}),"\n",(0,a.jsx)(t.p,{children:"A principle in agile software development that encourages avoiding unnecessary features. YAGNI helps teams focus on essential tasks to improve productivity."}),"\n",(0,a.jsx)(t.h2,{id:"theoretical-foundation",children:"Theoretical Foundation"}),"\n",(0,a.jsx)(t.p,{children:"YAGNI emerges from a deeper theoretical foundation concerning prediction accuracy and the economics of software development decisions. The principle challenges the common assumption that anticipating future requirements saves development effort, drawing on empirical studies showing that approximately 60-80% of speculative features are never used or substantially differ from actual future needs. YAGNI acknowledges the fundamental unpredictability of complex adaptive systems like software products and markets, recognizing that the most cost-effective approach is typically to optimize for current known requirements while maintaining appropriate flexibility. This theoretical basis connects YAGNI to concepts from options theory in finance, where deferring decisions until more information is available often creates greater economic value than premature commitment based on predictions."}),"\n",(0,a.jsx)(t.h2,{id:"common-misapplications",children:"Common Misapplications"}),"\n",(0,a.jsx)(t.p,{children:"Despite its apparent simplicity, YAGNI is frequently misapplied in ways that undermine its intended benefits and create significant technical problems. The most common misapplication treats YAGNI as permission to avoid architectural thinking entirely, producing brittle designs that resist extension when legitimate new requirements emerge. Another frequent misunderstanding applies YAGNI selectively to user-visible features while allowing speculative complexity in technical implementations, ignoring that the principle applies equally to both domains. Some teams invoke YAGNI to justify technical shortcuts that incur excessive technical debt, failing to distinguish between unnecessary features (which YAGNI discourages) and necessary quality attributes like maintainability (which YAGNI does not address). Effective application requires nuanced understanding of which design decisions genuinely constitute speculative features versus appropriate technical foundations."}),"\n",(0,a.jsx)(t.h2,{id:"practical-application",children:"Practical Application"}),"\n",(0,a.jsx)(t.p,{children:'Practical application of YAGNI involves specific techniques that help teams distinguish between essential complexity and speculative features during development. Effective implementations incorporate explicit requirement traceability, where teams regularly verify that implementation elements connect directly to validated user stories or acceptance criteria. Code review processes can include "YAGNI checks" that specifically question whether each component addresses current rather than speculative requirements. Some teams employ "complexity budgets" that limit the amount of code or architectural elements allowed for each user-facing feature, creating structural incentives to avoid speculative implementation. Perhaps most importantly, teams successful with YAGNI typically combine it with strong refactoring discipline, giving them confidence that code can be evolved efficiently when new requirements emerge, rather than requiring speculative pre-optimization.'})]})}function u(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>o,x:()=>r});var n=i(6540);const a={},s=n.createContext(a);function o(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);
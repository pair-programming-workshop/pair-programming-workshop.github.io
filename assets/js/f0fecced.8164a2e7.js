"use strict";(self.webpackChunkworkshop_pairprogramming_site=self.webpackChunkworkshop_pairprogramming_site||[]).push([[3711],{787:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"glossary/pair_debugging","title":"Pair Debugging","description":"Working together to identify and solve coding errors, which benefits from both partners\' perspectives and reduces the time needed to find and fix bugs.","source":"@site/docs/glossary/pair_debugging.md","sourceDirName":"glossary","slug":"/glossary/pair_debugging","permalink":"/docs/glossary/pair_debugging","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Pair Courage","permalink":"/docs/glossary/pair_courage"},"next":{"title":"Pair Learning","permalink":"/docs/glossary/pair_learning"}}');var o=n(4848),r=n(8453);const a={},s="Pair Debugging",l={},d=[{value:"Cognitive Advantages",id:"cognitive-advantages",level:2},{value:"Methodological Approaches",id:"methodological-approaches",level:2},{value:"Tool Utilization",id:"tool-utilization",level:2},{value:"Further reading",id:"further-reading",level:2}];function g(e){const i={a:"a",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(i.header,{children:(0,o.jsx)(i.h1,{id:"pair-debugging",children:"Pair Debugging"})}),"\n",(0,o.jsx)(i.p,{children:"Working together to identify and solve coding errors, which benefits from both partners' perspectives and reduces the time needed to find and fix bugs."}),"\n",(0,o.jsx)(i.h2,{id:"cognitive-advantages",children:"Cognitive Advantages"}),"\n",(0,o.jsx)(i.p,{children:"Pair debugging leverages significant cognitive advantages that accelerate problem resolution compared to solo debugging efforts. The primary advantage comes from complementary mental models, where each partner holds different assumptions about system behavior that can be explicitly compared and tested. This comparison quickly surfaces incorrect assumptions that might remain invisible to an individual working alone with a flawed mental model. Additionally, the verbalization requirement of explaining hypotheses to a partner forces more rigorous thinking than internal monologue, helping programmers avoid logical leaps and untested assumptions that frequently derail debugging sessions."}),"\n",(0,o.jsx)(i.h2,{id:"methodological-approaches",children:"Methodological Approaches"}),"\n",(0,o.jsx)(i.p,{children:'Successful pair debugging employs specific methodological approaches that differ from both solo debugging and standard pair programming. Effective pairs often use a "driver-observer" pattern where one partner executes specific debugging actions while the other observes system responses without the distraction of keyboard control, enabling more comprehensive observation of cause-effect relationships. Teams develop structured investigation protocols that prevent common debugging pitfalls like confirmation bias or premature hypothesis commitment, often incorporating formal techniques like bisection search or systematic state inspection that benefit from having distinct roles for execution and observation.'}),"\n",(0,o.jsx)(i.h2,{id:"tool-utilization",children:"Tool Utilization"}),"\n",(0,o.jsx)(i.p,{children:"Pair debugging significantly influences how development tools are selected and utilized during problem-solving sessions. Pairs typically leverage more powerful but complex debugging tools that individual developers might avoid due to setup overhead, finding the investment worthwhile given the amplified capabilities of two minds working together. Tool usage patterns show pairs more frequently employing visualization techniques like logging state changes, drawing diagrams, or creating temporary instrumentation to make system behavior visible and discussable. The most effective debugging pairs develop shared tool fluency through deliberate cross-training, ensuring both partners can seamlessly switch between tool operation and observation roles as the debugging session progresses."}),"\n",(0,o.jsx)(i.h2,{id:"further-reading",children:"Further reading"}),"\n",(0,o.jsxs)(i.ol,{children:["\n",(0,o.jsx)(i.li,{children:(0,o.jsx)(i.a,{href:"https://www.technetexperts.com/debugging-techniques-every-developer-should-know/",children:"25 Debugging Techniques Every Software Developer Should Master"})}),"\n",(0,o.jsx)(i.li,{children:(0,o.jsx)(i.a,{href:"https://www.academia.edu/20412723/Pair_Collaboration_in_End_User_Debugging",children:"Pair Collaboration in End-User Debugging - Academia.edu"})}),"\n"]})]})}function c(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,o.jsx)(i,{...e,children:(0,o.jsx)(g,{...e})}):g(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>a,x:()=>s});var t=n(6540);const o={},r=t.createContext(o);function a(e){const i=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function s(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),t.createElement(r.Provider,{value:i},e.children)}}}]);